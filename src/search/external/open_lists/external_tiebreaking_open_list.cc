#include "external_tiebreaking_open_list.h"

#include "../../open_list.h"
#include "../../option_parser.h"
#include "../../plugin.h"

#include "../../utils/memory.h"

#include <vector>
#include <map>

using namespace std;

namespace external_tiebreaking_open_list {
    template<class Entry>
    class ExternalTieBreakingOpenList : public OpenList<Entry> {
        using Bucket = deque<Entry>;

        map<const vector<int>, Bucket> buckets;
        int size;

        vector<Evaluator *> evaluators;
        //bool allow_unsafe_pruning;

    protected:
        virtual void do_insertion(EvaluationContext &eval_context,
                                  const Entry &entry) override;

    public:
        explicit ExternalTieBreakingOpenList(const Options &opts);
        virtual ~ExternalTieBreakingOpenList() override = default;

        virtual Entry remove_min() override;
        virtual void clear() override;
        virtual bool empty() const override;
        virtual void get_involved_heuristics(set<Heuristic *> &hset) override;
        virtual bool is_dead_end(EvaluationContext &eval_context) const override;
        virtual bool is_reliable_dead_end(EvaluationContext &eval_context) const override;
    };

    
    template<class Entry>
    ExternalTieBreakingOpenList<Entry>::ExternalTieBreakingOpenList(const Options &opts)
        : OpenList<Entry>(false), //opts.get<bool>("pref_only")),
        size(0), evaluators(opts.get_list<Evaluator *>("evals")) {
    }

    template<class Entry>
    void ExternalTieBreakingOpenList<Entry>::
    do_insertion(EvaluationContext &eval_context, const Entry &entry) {
        vector<int> key;
        key.reserve(evaluators.size());
        for (Evaluator *evaluator : evaluators)
            key.push_back(eval_context.get_heuristic_value_or_infinity(evaluator));

        buckets[key].push_back(entry);
        ++size;
    }

    template<class Entry>
    Entry ExternalTieBreakingOpenList<Entry>::remove_min() {
        assert(size > 0);
        typename map<const vector<int>, Bucket>::iterator it;
        it = buckets.begin();
        assert(it != buckets.end());
        assert(!it->second.empty());
        --size;
        Entry result = it->second.front();
        it->second.pop_front();
        if (it->second.empty())
            buckets.erase(it);
        return result;
    }

    template<class Entry>
    bool ExternalTieBreakingOpenList<Entry>::empty() const {
        return size == 0;
    }

    template<class Entry>
    void ExternalTieBreakingOpenList<Entry>::clear() {
        buckets.clear();
        size = 0;
    }

    template<class Entry>
    void ExternalTieBreakingOpenList<Entry>::
    get_involved_heuristics(set<Heuristic *> &hset) {
        for (Evaluator *evaluator : evaluators)
            evaluator->get_involved_heuristics(hset);
    }

    template<class Entry>
    bool ExternalTieBreakingOpenList<Entry>::
    is_dead_end(EvaluationContext &eval_context) const {
        // TODO: Properly document this behaviour.
        // If one safe heuristic detects a dead end, return true.
        if (is_reliable_dead_end(eval_context))
            return true;
        /*
        // If the first heuristic detects a dead-end and we allow "unsafe
        // pruning", return true.
        if (allow_unsafe_pruning &&
            eval_context.is_heuristic_infinite(evaluators[0]))
            return true;
        */
        // Otherwise, return true if all heuristics agree this is a dead-end.
        for (Evaluator *evaluator : evaluators)
            if (!eval_context.is_heuristic_infinite(evaluator))
                return false;
        return true;
    }

    template<class Entry>
    bool ExternalTieBreakingOpenList<Entry>::
    is_reliable_dead_end(EvaluationContext &eval_context) const {
        for (Evaluator *evaluator : evaluators)
            if (eval_context.is_heuristic_infinite(evaluator) &&
                evaluator->dead_ends_are_reliable())
                return true;
        return false;
    }

    
    ExternalTieBreakingOpenListFactory::
    ExternalTieBreakingOpenListFactory(const Options &options)
        : options(options) {
    }

    unique_ptr<StateOpenList>
    ExternalTieBreakingOpenListFactory::create_state_open_list() {
        return utils::make_unique_ptr
            <ExternalTieBreakingOpenList<StateOpenListEntry>>(options);
    }

    
    static shared_ptr<OpenListFactory> _parse(OptionParser &parser) {
        parser.document_synopsis("Tie-breaking open list", "");
        parser.add_list_option<Evaluator *>("evals", "evaluators");
        // Don't give option for preferred operators and unsafe pruning
        /*
        parser.add_option<bool>(
                                "pref_only",
                                "insert only nodes generated by preferred operators", "false");
        parser.add_option<bool>(
                                "unsafe_pruning",
                                "allow unsafe pruning when the main evaluator regards a state a dead end",
                                "true");
        */
        Options opts = parser.parse();
        opts.verify_list_non_empty<Evaluator *>("evals");
        if (parser.dry_run())
            return nullptr;
        else
            return make_shared<ExternalTieBreakingOpenListFactory>(opts);
    }

    static PluginShared<OpenListFactory> _plugin("external_tiebreaking", _parse);
}


        

        
